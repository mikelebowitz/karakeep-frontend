#!/usr/bin/env python3
"""
Pre-compact hook for Claude Code.
Generates comprehensive session documentation before context is cleared.
"""

import sys
import json
import os
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add utils to Python path
sys.path.insert(0, str(Path(__file__).parent / "utils"))

try:
    from git_analyzer import GitAnalyzer
    from doc_generator import DocumentationGenerator
except ImportError:
    print("Warning: Could not import utilities", file=sys.stderr)
    GitAnalyzer = None
    DocumentationGenerator = None

class PreCompactHook:
    def __init__(self):
        self.repo_path = Path(__file__).parent.parent.parent
        self.session_docs_dir = self.repo_path / "docs" / "sessions"
        self.session_file = Path("/tmp/claude-gitops-session.json")
        self.debug = os.environ.get('CLAUDE_HOOKS_DEBUG', '').lower() == 'true'
        
        # Create session docs directory if needed
        self.session_docs_dir.mkdir(parents=True, exist_ok=True)
        
        if GitAnalyzer:
            self.git_analyzer = GitAnalyzer(str(self.repo_path))
        else:
            self.git_analyzer = None
    
    def log(self, message: str):
        """Log debug messages."""
        if self.debug:
            print(f"[PRE-COMPACT] {message}", file=sys.stderr)
    
    def process(self, input_data: Dict) -> Dict:
        """Process pre-compact event."""
        try:
            session_id = input_data.get('session_id', 'unknown')
            trigger = input_data.get('trigger', 'unknown')
            custom_instructions = input_data.get('custom_instructions', '')
            
            self.log(f"Processing {trigger} compaction for session {session_id}")
            
            # Generate session documentation
            session_doc_path = self.generate_session_documentation(
                session_id, trigger, custom_instructions
            )
            
            # Create NEXT_SESSION.md for continuity
            self.create_next_session_brief()
            
            # Update project status files
            self.update_project_status()
            
            # Create git commit if there are changes
            if self.git_analyzer and self.git_analyzer.has_changes():
                self.create_session_commit(session_id, trigger)
            
            # Clean up session data
            if self.session_file.exists():
                self.session_file.unlink()
                self.log("Cleaned up session data")
            
            return {
                "success": True,
                "session_documented": True,
                "doc_path": str(session_doc_path)
            }
            
        except Exception as e:
            self.log(f"Error: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def generate_session_documentation(self, session_id: str, trigger: str, 
                                      custom_instructions: str) -> Path:
        """Generate comprehensive session documentation."""
        timestamp = datetime.now()
        doc_filename = f"SESSION_{timestamp.strftime('%Y-%m-%d_%H-%M')}.md"
        doc_path = self.session_docs_dir / doc_filename
        
        # Load session operations if available
        session_operations = self.load_session_operations()
        
        # Analyze git changes
        changes_summary = self.analyze_changes()
        
        # Generate document content
        content = f"""# Development Session Summary

**Session ID**: {session_id}
**Date**: {timestamp.strftime('%B %d, %Y %H:%M')}
**Trigger**: {trigger.capitalize()} compaction
{f'**Instructions**: {custom_instructions}' if custom_instructions else ''}

## Session Metrics

- **Duration**: {self.calculate_session_duration(session_operations)}
- **Operations**: {len(session_operations)} tool uses
- **Files Changed**: {changes_summary.get('files_changed', 0)}
- **Lines Added**: {changes_summary.get('insertions', 0)}
- **Lines Removed**: {changes_summary.get('deletions', 0)}

## Achievements

{self.generate_achievements_section(session_operations, changes_summary)}

## Code Changes

{self.generate_code_changes_section(changes_summary)}

## Key Operations

{self.generate_operations_timeline(session_operations)}

## Git Status

```bash
# Current branch
{self.get_current_branch()}

# Uncommitted changes
{self.get_git_status()}
```

## Next Session TODOs

{self.extract_todos_from_session(session_operations)}

## Context to Restore

- Last working directory: `{os.getcwd()}`
- Active development: {self.identify_active_development(changes_summary)}
- Key files to review: {self.list_key_files(changes_summary)}

---

*Generated by Claude Code pre-compact hook*
"""
        
        # Write documentation
        doc_path.write_text(content)
        self.log(f"Created session documentation: {doc_path}")
        
        return doc_path
    
    def load_session_operations(self) -> List[Dict]:
        """Load operations from session file."""
        try:
            if self.session_file.exists():
                with open(self.session_file) as f:
                    data = json.load(f)
                    return data.get('operations', [])
        except Exception as e:
            self.log(f"Could not load session operations: {e}")
        
        return []
    
    def analyze_changes(self) -> Dict:
        """Analyze git changes in the session."""
        if not self.git_analyzer:
            return {}
        
        try:
            summary = self.git_analyzer.generate_change_summary()
            return summary.get('diff_stats', {})
        except Exception as e:
            self.log(f"Could not analyze changes: {e}")
            return {}
    
    def calculate_session_duration(self, operations: List[Dict]) -> str:
        """Calculate session duration from operations."""
        if not operations:
            return "Unknown"
        
        try:
            first_op = operations[0].get('timestamp', 0)
            last_op = operations[-1].get('timestamp', 0)
            
            if isinstance(first_op, str):
                first_op = datetime.fromisoformat(first_op).timestamp()
            if isinstance(last_op, str):
                last_op = datetime.fromisoformat(last_op).timestamp()
            
            duration_seconds = int(last_op - first_op)
            hours = duration_seconds // 3600
            minutes = (duration_seconds % 3600) // 60
            
            if hours > 0:
                return f"{hours}h {minutes}m"
            else:
                return f"{minutes}m"
        except Exception:
            return "Unknown"
    
    def generate_achievements_section(self, operations: List[Dict], 
                                    changes_summary: Dict) -> str:
        """Generate achievements based on operations."""
        achievements = []
        
        # Analyze operations for patterns
        tools_used = {}
        for op in operations:
            tool = op.get('tool', 'Unknown')
            tools_used[tool] = tools_used.get(tool, 0) + 1
        
        # Generate achievements
        if tools_used.get('Write', 0) > 0:
            achievements.append(f"✅ Created {tools_used['Write']} new files")
        
        if tools_used.get('Edit', 0) > 0:
            achievements.append(f"✅ Modified {tools_used['Edit']} files")
        
        if tools_used.get('MultiEdit', 0) > 0:
            achievements.append(f"✅ Performed {tools_used['MultiEdit']} multi-file edits")
        
        if tools_used.get('Bash', 0) > 0:
            achievements.append(f"✅ Executed {tools_used['Bash']} commands")
        
        if not achievements:
            achievements.append("- Session in progress")
        
        return "\n".join(achievements)
    
    def generate_code_changes_section(self, changes_summary: Dict) -> str:
        """Generate code changes section."""
        if not self.git_analyzer:
            return "- Unable to analyze code changes"
        
        try:
            changed_files = self.git_analyzer.get_changed_files()
            if not changed_files:
                return "- No uncommitted changes"
            
            sections = []
            
            # Group by change type
            added = [f for f in changed_files if f['change_type'] == 'added']
            modified = [f for f in changed_files if f['change_type'] == 'modified']
            deleted = [f for f in changed_files if f['change_type'] == 'deleted']
            
            if added:
                sections.append("### New Files")
                for f in added:
                    sections.append(f"- `{f['filename']}`")
            
            if modified:
                sections.append("\n### Modified Files")
                for f in modified:
                    sections.append(f"- `{f['filename']}`")
            
            if deleted:
                sections.append("\n### Deleted Files")
                for f in deleted:
                    sections.append(f"- `{f['filename']}`")
            
            return "\n".join(sections)
            
        except Exception as e:
            return f"- Error analyzing changes: {e}"
    
    def generate_operations_timeline(self, operations: List[Dict]) -> str:
        """Generate timeline of key operations."""
        if not operations:
            return "- No operations recorded"
        
        timeline = []
        for i, op in enumerate(operations[-10:]):  # Last 10 operations
            tool = op.get('tool', 'Unknown')
            tool_input = op.get('tool_input', {})
            
            # Extract key info based on tool type
            if tool == 'Edit':
                file_path = tool_input.get('file_path', 'unknown')
                timeline.append(f"{i+1}. **Edit**: `{file_path}`")
            elif tool == 'Write':
                file_path = tool_input.get('file_path', 'unknown')
                timeline.append(f"{i+1}. **Create**: `{file_path}`")
            elif tool == 'Bash':
                command = tool_input.get('command', 'unknown')
                timeline.append(f"{i+1}. **Command**: `{command[:50]}...`")
            else:
                timeline.append(f"{i+1}. **{tool}**: Operation performed")
        
        return "\n".join(timeline)
    
    def get_current_branch(self) -> str:
        """Get current git branch."""
        try:
            result = subprocess.run(
                ['git', 'branch', '--show-current'],
                capture_output=True,
                text=True,
                cwd=self.repo_path
            )
            return result.stdout.strip() or "unknown"
        except Exception:
            return "unknown"
    
    def get_git_status(self) -> str:
        """Get git status output."""
        try:
            result = subprocess.run(
                ['git', 'status', '--short'],
                capture_output=True,
                text=True,
                cwd=self.repo_path
            )
            return result.stdout or "No changes"
        except Exception:
            return "Unable to get git status"
    
    def extract_todos_from_session(self, operations: List[Dict]) -> str:
        """Extract TODOs from session operations."""
        # This would analyze operations for TODO comments
        # For now, return placeholder
        return """- [ ] Review and test recent changes
- [ ] Update documentation if needed
- [ ] Continue with next planned features"""
    
    def identify_active_development(self, changes_summary: Dict) -> str:
        """Identify what was being actively developed."""
        # Analyze file patterns to determine focus area
        return "Feature development in progress"
    
    def list_key_files(self, changes_summary: Dict) -> str:
        """List key files that were modified."""
        if not self.git_analyzer:
            return "[]"
        
        try:
            changed_files = self.git_analyzer.get_changed_files()
            key_files = [f['filename'] for f in changed_files[:5]]  # Top 5
            return json.dumps(key_files)
        except Exception:
            return "[]"
    
    def create_next_session_brief(self):
        """Create a brief for the next session."""
        brief_path = self.repo_path / "NEXT_SESSION.md"
        
        content = f"""# Next Session Brief

**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M')}

## Quick Context

**Branch**: {self.get_current_branch()}
**Last Activity**: {datetime.now().strftime('%B %d, %Y')}

## Resume Command

```bash
cd {self.repo_path}
npm run dev  # If development server was running
```

## Active TODOs

Check `docs/sessions/` for the latest session summary.

## Git Status Summary

```
{self.get_git_status()}
```

---

*This file helps you quickly resume development in the next session.*
"""
        
        brief_path.write_text(content)
        self.log("Created NEXT_SESSION.md")
    
    def update_project_status(self):
        """Update project status files."""
        # This would update CURRENT_STATUS.md or similar files
        # For now, just log
        self.log("Project status update skipped (not implemented)")
    
    def create_session_commit(self, session_id: str, trigger: str):
        """Create a git commit for the session."""
        try:
            # Stage documentation files
            subprocess.run(
                ['git', 'add', 'docs/sessions/', 'NEXT_SESSION.md'],
                cwd=self.repo_path,
                check=True
            )
            
            # Create commit
            commit_message = f"""docs: Session summary before {trigger} compaction

- Session ID: {session_id}
- Generated comprehensive session documentation
- Created next session brief for continuity
- Preserved all work before context reset

[Auto-generated by pre-compact hook]"""
            
            subprocess.run(
                ['git', 'commit', '-m', commit_message],
                cwd=self.repo_path,
                check=True
            )
            
            self.log("Created session documentation commit")
            
        except subprocess.CalledProcessError as e:
            self.log(f"Could not create commit: {e}")

def main():
    """Main entry point for pre-compact hook."""
    try:
        # Read input
        input_data = json.load(sys.stdin)
        
        # Process hook
        hook = PreCompactHook()
        result = hook.process(input_data)
        
        # Output result to stderr for debugging (not stdout)
        print(json.dumps(result), file=sys.stderr)
        
        # Exit with appropriate code
        sys.exit(0 if result.get('success', False) else 1)
        
    except Exception as e:
        print(f"Fatal error in pre-compact hook: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()